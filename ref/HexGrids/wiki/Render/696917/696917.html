<div class="wikidoc">This elegant algorithm is from <a href="http://playtechs.blogspot.ca/2007/04/hex-grids.html">James McNeill</a>. I cannot say much to improve on his explanation, so I will only note that a few details specific to this implementation have been filled in. <br /><br />From the <b>Grid Coordinates</b> section of <b>HexgridPanel.cs</b>:<br /><br /><pre>
    /// Mathemagically (left as exercise for the reader) our &#39;picking&#39; matrices are 
    /// these, assuming: 
    ///  - origin at upper-left corner of hex (0,0);
    ///  - &#39;straight&#39; hex-axis vertically down; and
    ///  - &#39;oblique&#39;  hex-axis up-and-to-right (at 120 degrees from &#39;straight&#39;).
    private Matrix matrixX { 
      get { return new Matrix((3.0F/2.0F)/GridSize.Width,  (3.0F/2.0F)/GridSize.Width,
                                    1.0F/GridSize.Height,       -1.0F/GridSize.Height,  -0.5F,-0.5F); } 
    }
    private Matrix matrixY { 
      get { return new Matrix(       0.0F,                 (3.0F/2.0F)/GridSize.Width,
                                   2.0F/GridSize.Height,         1.0F/GridSize.Height,  -0.5F,-0.5F); } 
    }

    /// &lt;summary&gt;Canonical coordinates for a selected hex for a given AutoScroll position.&lt;/summary&gt;
    /// &lt;param name=&quot;point&quot;&gt;Screen point specifying hex to be identified.&lt;/param&gt;
    /// &lt;param name=&quot;autoScroll&quot;&gt;AutoScrollPosition for game-display Panel.&lt;/param&gt;
    /// &lt;returns&gt;Canonical coordinates for a hex specified by a screen point.&lt;/returns&gt;
    /// &lt;see cref=&quot;HexGridAlgorithm.mht&quot;/&gt;
    protected ICoordsCanon GetHexCoords(Point point, Size autoScroll) {
      if( Host == null ) return Coords.EmptyCanon;

      autoScroll = TransposeSize(autoScroll);

      /// Adjust for origin not as assumed by GetCoordinate().
      var grid    = new Size((int)(GridSize.Width*2F/3F), (int)GridSize.Height);
      var margin  = new Size((int)(MapMargin.Width *MapScale), 
                             (int)(MapMargin.Height*MapScale));

      point      -= autoScroll + margin + grid;
      return Coords.NewCanonCoords( GetCoordinate(matrixX, point), 
                                    GetCoordinate(matrixY, point) );
    }

    Size TransposeSize(Size size) { return IsTransposed ? new Size (size.Height, size.Width)
                                                        : size; }

    /// &lt;summary&gt;Calculates a (canonical X or Y) grid-coordinate for a point, from the supplied &#39;picking&#39; matrix.&lt;/summary&gt;
    /// &lt;param name=&quot;matrix&quot;&gt;The &#39;picking&#39; matrix&lt;/param&gt;
    /// &lt;param name=&quot;point&quot;&gt;The screen point identifying the hex to be &#39;picked&#39;.&lt;/param&gt;
    /// &lt;returns&gt;A (canonical X or Y) grid coordinate of the &#39;picked&#39; hex.&lt;/returns&gt;
	  private static int GetCoordinate (Matrix matrix, Point point){
      var pts = new Point[] {point};
      matrix.TransformPoints(pts);
		  return (int) Math.Floor( (pts[0].X + pts[0].Y + 2F) / 3F );
	  }
</pre></div><div class="ClearBoth"></div>