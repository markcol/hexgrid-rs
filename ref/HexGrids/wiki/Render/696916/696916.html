<div class="wikidoc">Everything is provided, except (of course) the game-specific StepCost function. Invoke the PathFInder as shown here from <b>HexgridPanel.cs</b>:<br /><br /><pre>
    protected override void OnMouseClick(MouseEventArgs e) {
      if (e.Button == MouseButtons.Left) {
        Host.CurrentHex = GetHexCoords(e.Location).User;
      } else {
        ost.HotSpotHex = GetHexCoords(e.Location).User;
      }

      Path = PathFinder.FindPath(
        Host.CurrentHex.Canon, 
        Host.HotSpotHex.Canon, 
        (c,hs) =&gt; Host.StepCost(c,hs), 
        c =&gt; Host.HotSpotHex.Canon.Range(c),
        c =&gt; Host.IsOnBoard(c.User)
      );

      Refresh();
    }
</pre><br />with <b>FindPath</b> prototype:<br /><pre>
    public static IPath&lt;ICoordsCanon&gt; FindPath( 
      ICoordsCanon start, 
      ICoordsCanon goal,
      Func&lt;ICoordsCanon,Hexside,int&gt; stepCost,
      Func&lt;ICoordsCanon,int&gt;         estimate,
      Func&lt;ICoordsCanon,bool&gt;        isOnBoard
  }
</pre><br />The example StepCost function implements a simple clear/blocked terrain, but any cost function of the hex being entered and the hexside being traversed can be provided. <br />The algorithms is from <a href="http://blogs.msdn.com/b/ericlippert/archive/2007/10/02/path-finding-using-a-in-c-3-0.aspx">Eric Lippert&#39;s</a> excellent blog articles on A-*, adapted to a hex-grid, and to to weight the most direct path favourably for better (visual) behaviour on a hexgrid.
<h2>Note</h2>One asumption is made that, in writing this documentation, I realize should be enforced by the code but isn&#39;t (yet).:
<ul><li>StepCost must fit in a <b>short</b>.</li></ul>
The reason for this is the implementation of the weighting used to favour direct paths on a hex grid (excerpted from <b>Pathfinder.FindPath</b>:<br /><pre>
        foreach (var neighbour in path.LastStep.GetNeighbours(~Hexside.None)) {
          if (isOnBoard(neighbour.Coords.Canon)) {
            var preference    = (ushort)vectorGoal.VectorCross(goal.Vector - neighbour.Coords.Canon.Vector);
            var cost          = stepCost(path.LastStep, neighbour.Direction);
            if (cost &gt; 0) {
              var newPath     = path.AddStep(neighbour.Coords.Canon, (ushort)cost, neighbour.Direction); 
              var newEstimate = ((uint)estimate(neighbour.Coords.Canon) + (uint)newPath.TotalCost) &lt;&lt; 16;
              queue.Enqueue(newEstimate + preference, newPath);
              DebugTracing.Trace(TraceFlag.FindPath, &quot;   Enqueue {0}: {1} / {2}; / {3}&quot;,
                      neighbour.Coords, newEstimate&gt;&gt;16, newEstimate &amp; 0x0FFFF, preference);
            }
          }
        }
</pre><br />using this definition of VectorCross:<br /><pre>
    public static int VectorCross (this IntVector2D lhs, IntVector2D rhs) {
      return Math.Abs(lhs.X*rhs.Y - lhs.Y*rhs.X);
    }
</pre><br />Note how <b>newEstimate</b> and <b>preference</b> are placed in the high- and low-order 16 bits, respectively, of the step estimate to induce the desired weighting of paths with an equal actual cost.</div><div class="ClearBoth"></div>